// Project Template Script - Minimal functionality for frame sizing

class ProjectTemplate {
    constructor() {
        this.frameContainer = document.getElementById('frameContainer');
        this.widthInput = document.getElementById('frameWidth');
        this.heightInput = document.getElementById('frameHeight');
        this.applySizeBtn = document.getElementById('applySizeBtn');
        
        // Image upload controls
        this.uploadButton = document.getElementById('uploadButton');
        this.imageInput = document.getElementById('imageInput');
        this.thumbnailsContainer = document.getElementById('thumbnailsContainer');
        
        // Preset control
        this.presetSelect = document.getElementById('presetSelect');
        
        // Spline controls
        this.splineSpeedSlider = document.getElementById('splineSpeedSlider');
        this.splineSpeedValue = document.getElementById('splineSpeedValue');
        this.splineScaleSlider = document.getElementById('splineScaleSlider');
        this.splineScaleValue = document.getElementById('splineScaleValue');
        this.splineDensitySlider = document.getElementById('splineDensitySlider');
        this.splineDensityValue = document.getElementById('splineDensityValue');
        
        // Slider controls
        this.radiusSlider = document.getElementById('radiusSlider');
        this.radiusValue = document.getElementById('radiusValue');
        this.heightSlider = document.getElementById('heightSlider');
        this.heightValue = document.getElementById('heightValue');
        this.scaleSlider = document.getElementById('scaleSlider');
        this.scaleValue = document.getElementById('scaleValue');
        this.speedSlider = document.getElementById('speedSlider');
        this.speedValue = document.getElementById('speedValue');
        this.rotationXSlider = document.getElementById('rotationXSlider');
        this.rotationXValue = document.getElementById('rotationXValue');
        this.rotationZSlider = document.getElementById('rotationZSlider');
        this.rotationZValue = document.getElementById('rotationZValue');
        this.resetRotationBtn = document.getElementById('resetRotationBtn');
        
        // Three.js properties
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.rotationGroup = null; // Parent group for manual rotation controls
        this.pathGroup = null; // Child group for internal animation
        this.circularPath = null;
        this.pathMarkers = [];
        this.centerSphere = null;
        this.animationId = null;
        this.currentRadius = 3;
        this.currentHeight = 0; // Y offset for the circular path
        this.worldRotation = { x: 0, y: 0, z: 0 }; // Local space rotation values
        
        // 2D Canvas properties for spline mode
        this.canvas2D = null;
        this.ctx2D = null;
        this.isDrawing = false;
        this.splinePoints = [];
        this.currentSpline = [];
        this.splineCumulativeDistances = null; // For distance-based interpolation
        
        // 2D Image properties for spline mode
        this.imageElements2D = []; // Array to store 2D image elements
        this.splineAnimationDistance = 0; // Track absolute distance traveled
        this.splineAnimationSpeed = 0.5; // Speed in pixels per frame (absolute speed)
        this.splineAnimationId = null; // Track animation frame to prevent multiple loops
        this.splineImageScale = 1.0; // Scale for images in spline mode
        this.splineImageDensity = 1; // Density control (1=few duplicates, 10=lots of duplicates)
        this.isRecreatingImages = false; // Prevent multiple simultaneous recreations
        
        // Gallery properties
        this.uploadedImages = []; // Array to store uploaded image data
        this.imagePlanes = []; // Array to store Three.js image planes
        this.animationTime = 0; // For animating images along the path
        this.currentScale = 1.5; // Default scale for images
        this.currentSpeed = 0.5; // Default rotation speed (degrees per frame)
        this.currentPreset = 'ring'; // Current gallery preset
        
        // Placeholder frames
        this.placeholderPlane = null; // 3D placeholder for ring mode
        this.hasPlaceholder = true; // Track if placeholder should be shown
        
        this.initEventListeners();
        this.initThreeJS();
    }
    
    initEventListeners() {
        // Apply size button
        this.applySizeBtn.addEventListener('click', () => {
            this.applyFrameSize();
        });
        
        // Enter key in inputs
        this.widthInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.applyFrameSize();
            }
        });
        
        this.heightInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                this.applyFrameSize();
            }
        });
        
        // Input validation - only allow numbers
        [this.widthInput, this.heightInput].forEach(input => {
            input.addEventListener('input', (e) => {
                e.target.value = e.target.value.replace(/[^0-9]/g, '');
            });
        });
        
        // Image upload event listeners
        this.uploadButton.addEventListener('click', () => {
            this.imageInput.click();
        });
        
        this.imageInput.addEventListener('change', (e) => {
            this.handleImageUpload(e);
        });
        
        // Preset selector
        this.presetSelect.addEventListener('change', (e) => {
            this.handlePresetChange(e.target.value);
        });
        
        // Spline speed slider
        this.splineSpeedSlider.addEventListener('input', (e) => {
            this.splineAnimationSpeed = parseFloat(e.target.value);
            this.splineSpeedValue.textContent = this.splineAnimationSpeed.toString();
        });
        
        // Spline scale slider
        this.splineScaleSlider.addEventListener('input', (e) => {
            this.splineImageScale = parseFloat(e.target.value);
            this.splineScaleValue.textContent = this.splineImageScale.toFixed(1);
            this.updateSplineImageScales();
        });
        
        // Spline density slider
        this.splineDensitySlider.addEventListener('change', (e) => {
            this.splineImageDensity = parseInt(e.target.value);
            this.splineDensityValue.textContent = this.splineImageDensity.toString();
            // Recreate images with new density
            if (this.splinePoints.length > 0) {
                this.createImagesAlongSpline();
            }
        });
        
        // Also update the display value while dragging (but don't recreate images)
        this.splineDensitySlider.addEventListener('input', (e) => {
            this.splineDensityValue.textContent = e.target.value;
        });
        
        // Radius slider
        this.radiusSlider.addEventListener('input', (e) => {
            this.currentRadius = parseFloat(e.target.value);
            this.radiusValue.textContent = this.currentRadius.toFixed(1);
            this.updateCircularPath();
            this.updateImagePositions();
        });
        
        // Height slider
        this.heightSlider.addEventListener('input', (e) => {
            this.currentHeight = parseFloat(e.target.value);
            this.heightValue.textContent = this.currentHeight.toFixed(1);
            this.updateCircularPath();
            this.updateImagePositions();
        });
        
        // Scale slider
        this.scaleSlider.addEventListener('input', (e) => {
            this.currentScale = parseFloat(e.target.value);
            this.scaleValue.textContent = this.currentScale.toFixed(1);
            this.updateImageScales();
        });
        
        // Speed slider
        this.speedSlider.addEventListener('input', (e) => {
            this.currentSpeed = parseFloat(e.target.value);
            this.speedValue.textContent = this.currentSpeed.toFixed(1);
        });
        
        // Rotation sliders - now using world space rotations
        this.rotationXSlider.addEventListener('input', (e) => {
            this.worldRotation.x = parseInt(e.target.value);
            this.rotationXValue.textContent = `${this.worldRotation.x}°`;
            this.updateWorldRotation();
        });
        
        this.rotationZSlider.addEventListener('input', (e) => {
            this.worldRotation.z = parseInt(e.target.value);
            this.rotationZValue.textContent = `${this.worldRotation.z}°`;
            this.updateWorldRotation();
        });
        
        // Reset rotation button
        this.resetRotationBtn.addEventListener('click', () => {
            this.resetRotation();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            this.onWindowResize();
        });
        
        // Mouse events for spline drawing (will be activated in spline mode)
        this.setupSplineDrawingEvents();
    }
    
    setupSplineDrawingEvents() {
        // Mouse events for 2D spline drawing
        this.frameContainer.addEventListener('mousedown', (e) => {
            if (this.currentPreset === 'follow-spline') {
                this.startDrawing(e);
            }
        });
        
        this.frameContainer.addEventListener('mousemove', (e) => {
            if (this.currentPreset === 'follow-spline' && this.isDrawing) {
                this.continueDrawing(e);
            }
        });
        
        this.frameContainer.addEventListener('mouseup', (e) => {
            if (this.currentPreset === 'follow-spline') {
                this.stopDrawing(e);
            }
        });
        
        this.frameContainer.addEventListener('mouseleave', (e) => {
            if (this.currentPreset === 'follow-spline') {
                this.stopDrawing(e);
            }
        });
    }
    
    startDrawing(e) {
        // Clear previous spline and start new one
        this.splinePoints = [];
        this.currentSpline = [];
        this.splineCumulativeDistances = null; // Reset distance calculations
        this.isDrawing = true;
        
        // Get mouse position relative to canvas
        const rect = this.frameContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Add first point
        this.currentSpline.push({ x, y });
        this.clearCanvas();
        this.drawSpline();
    }
    
    continueDrawing(e) {
        if (!this.isDrawing) return;
        
        // Get mouse position relative to canvas
        const rect = this.frameContainer.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Add point to current spline
        this.currentSpline.push({ x, y });
        this.drawSpline();
    }
    
    stopDrawing(e) {
        if (!this.isDrawing) return;
        
        this.isDrawing = false;
        // Store the completed spline
        this.splinePoints = [...this.currentSpline];
        console.log('Spline completed with', this.splinePoints.length, 'points');
        
        // Small delay to ensure spline rendering is complete before positioning images
        setTimeout(() => {
            this.createImagesAlongSpline();
        }, 50);
    }
    
    clearCanvas() {
        if (this.ctx2D) {
            this.ctx2D.clearRect(0, 0, this.canvas2D.width, this.canvas2D.height);
            // Set background color to match frame
            this.ctx2D.fillStyle = '#181818';
            this.ctx2D.fillRect(0, 0, this.canvas2D.width, this.canvas2D.height);
        }
    }
    
    drawSpline() {
        if (!this.ctx2D || this.currentSpline.length < 2) return;
        
        this.clearCanvas();
        
        // Draw the spline
        this.ctx2D.strokeStyle = '#00ff88';
        this.ctx2D.lineWidth = 3;
        this.ctx2D.lineCap = 'round';
        this.ctx2D.lineJoin = 'round';
        
        this.ctx2D.beginPath();
        this.ctx2D.moveTo(this.currentSpline[0].x, this.currentSpline[0].y);
        
        // Draw smooth curve through points
        for (let i = 1; i < this.currentSpline.length; i++) {
            this.ctx2D.lineTo(this.currentSpline[i].x, this.currentSpline[i].y);
        }
        
        this.ctx2D.stroke();
    }
    
    handleImageUpload(event) {
        const files = Array.from(event.target.files);
        
        files.forEach(file => {
            if (file.type.startsWith('image/')) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const imageData = {
                        id: Date.now() + Math.random(), // Unique ID
                        file: file,
                        dataUrl: e.target.result,
                        name: file.name
                    };
                    
                    this.uploadedImages.push(imageData);
                    this.createThumbnail(imageData);
                    
                    // Remove placeholder if this is the first image
                    if (this.uploadedImages.length === 1) {
                        this.removePlaceholders();
                    }
                    
                    // Create image representation for current mode
                    if (this.currentPreset === 'ring') {
                        this.createImagePlane(imageData);
                        this.updateImagePositions();
                    } else if (this.currentPreset === 'follow-spline' && this.splinePoints.length > 0) {
                        // Recreate all images along spline
                        this.createImagesAlongSpline();
                    }
                };
                reader.readAsDataURL(file);
            }
        });
        
        // Reset the input
        event.target.value = '';
    }
    
    createThumbnail(imageData) {
        const thumbnailItem = document.createElement('div');
        thumbnailItem.className = 'thumbnail-item';
        thumbnailItem.dataset.imageId = imageData.id;
        
        const img = document.createElement('img');
        img.className = 'thumbnail-image';
        img.src = imageData.dataUrl;
        img.alt = imageData.name;
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'thumbnail-remove';
        removeBtn.innerHTML = '×';
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.removeImage(imageData.id);
        });
        
        thumbnailItem.appendChild(img);
        thumbnailItem.appendChild(removeBtn);
        this.thumbnailsContainer.appendChild(thumbnailItem);
    }
    
    removeImage(imageId) {
        // Remove from uploaded images array
        this.uploadedImages = this.uploadedImages.filter(img => img.id !== imageId);
        
        // Show placeholder if no images left
        if (this.uploadedImages.length === 0) {
            this.showPlaceholders();
        }
        
        // Remove thumbnail from DOM
        const thumbnail = this.thumbnailsContainer.querySelector(`[data-image-id="${imageId}"]`);
        if (thumbnail) {
            thumbnail.remove();
        }
        
        if (this.currentPreset === 'ring') {
            // Remove from Three.js scene and recreate all
            this.imagePlanes = []; // Clear all planes
            // Remove all planes from the scene
            const planesToRemove = [];
            this.pathGroup.children.forEach(child => {
                if (child.userData && child.userData.imageId) {
                    planesToRemove.push(child);
                }
            });
            planesToRemove.forEach(plane => {
                this.pathGroup.remove(plane);
                if (plane.geometry) plane.geometry.dispose();
                if (plane.material) {
                    if (plane.material.map) plane.material.map.dispose();
                    plane.material.dispose();
                }
            });
            
            // Recreate all remaining images
            this.uploadedImages.forEach(imageData => {
                this.createImagePlane(imageData);
            });
            this.updateImagePositions();
            
        } else if (this.currentPreset === 'follow-spline') {
            // Recreate images along spline with updated list
            if (this.splinePoints.length > 0) {
                this.createImagesAlongSpline();
            }
        }
    }
    
    handlePresetChange(preset) {
        this.currentPreset = preset;
        
        switch (preset) {
            case 'ring':
                // Show current ring gallery
                this.showRingGallery();
                break;
            case 'follow-spline':
                // Show empty canvas for now
                this.showFollowSplineGallery();
                break;
            default:
                console.log('Unknown preset:', preset);
        }
    }
    
    showRingGallery() {
        // Enable ring gallery mode (current functionality)
        this.pathGroup.visible = true;
        
        // Show ring-specific UI controls
        this.showRingControls();
        
        // Show Three.js renderer and hide 2D canvas
        if (this.renderer) {
            this.renderer.domElement.style.display = 'block';
        }
        if (this.canvas2D) {
            this.canvas2D.style.display = 'none';
        }
        
        // Clear 2D images
        this.clear2DImages();
        
        // Recreate the circular path
        this.createCircularPath();
        
        // Create 3D planes for all uploaded images
        this.imagePlanes = []; // Clear existing planes
        this.uploadedImages.forEach(imageData => {
            this.createImagePlane(imageData);
        });
        
        // Update positions of all images
        this.updateImagePositions();
        
        // Show placeholder if no images
        if (this.uploadedImages.length === 0) {
            this.showRingPlaceholder();
        }
        
        console.log('Ring gallery mode activated');
    }
    
    showFollowSplineGallery() {
        // Hide ring elements for empty canvas
        this.pathGroup.visible = false;
        
        // Hide ring-specific UI controls
        this.hideRingControls();
        
        // Hide Three.js renderer and show 2D canvas
        if (this.renderer) {
            this.renderer.domElement.style.display = 'none';
        }
        
        // Create or show 2D canvas for spline drawing
        this.setup2DCanvas();
        
        // Show spline instruction text if no spline is drawn
        if (this.splinePoints.length === 0) {
            this.drawSplinePlaceholder();
        } else if (this.uploadedImages.length > 0) {
            // Create 2D images for uploaded images if there's a spline
            this.createImagesAlongSpline();
        }
        
        console.log('Follow spline mode activated - 2D canvas ready for drawing');
    }
    
    showRingControls() {
        // Show controls specific to ring gallery
        const imageScaleSection = document.getElementById('imageScaleSection');
        const circlePropertiesSection = document.getElementById('circlePropertiesSection');
        const splinePropertiesSection = document.getElementById('splinePropertiesSection');
        
        if (imageScaleSection) imageScaleSection.style.display = 'block';
        if (circlePropertiesSection) circlePropertiesSection.style.display = 'block';
        if (splinePropertiesSection) splinePropertiesSection.style.display = 'none';
    }
    
    hideRingControls() {
        // Hide controls specific to ring gallery and show spline controls
        const imageScaleSection = document.getElementById('imageScaleSection');
        const circlePropertiesSection = document.getElementById('circlePropertiesSection');
        const splinePropertiesSection = document.getElementById('splinePropertiesSection');
        
        if (imageScaleSection) imageScaleSection.style.display = 'none';
        if (circlePropertiesSection) circlePropertiesSection.style.display = 'none';
        if (splinePropertiesSection) splinePropertiesSection.style.display = 'block';
    }
    
    createImagePlane(imageData) {
        const loader = new THREE.TextureLoader();
        loader.load(imageData.dataUrl, (texture) => {
            // Ensure texture uses proper color space and preserves alpha
            texture.colorSpace = THREE.SRGBColorSpace;
            
            // Create geometry for the image plane
            const geometry = new THREE.PlaneGeometry(1, 1);
            
            // Create material with the image texture - support alpha transparency
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                side: THREE.DoubleSide,
                transparent: true,  // Enable transparency for PNG alpha
                alphaTest: 0.1,     // Discard pixels with alpha < 0.1 for better performance
                toneMapped: false   // Disable tone mapping for true colors
            });
            
            // Create the plane mesh
            const plane = new THREE.Mesh(geometry, material);
            plane.userData.imageId = imageData.id;
            plane.userData.originalSize = {
                width: texture.image.width,
                height: texture.image.height
            };
            
            // Scale the plane to maintain aspect ratio with current scale
            const aspectRatio = texture.image.width / texture.image.height;
            if (aspectRatio > 1) {
                // Landscape
                plane.scale.set(this.currentScale, this.currentScale / aspectRatio, 1);
            } else {
                // Portrait
                plane.scale.set(this.currentScale * aspectRatio, this.currentScale, 1);
            }
            
            this.imagePlanes.push(plane);
            this.pathGroup.add(plane);
            this.updateImagePositions();
        });
    }
    
    updateImagePositions() {
        if (this.imagePlanes.length === 0) return;
        
        // Calculate static positions in LOCAL space (not affected by parent rotation)
        const radius = this.currentRadius + 1; // Slightly outside the path
        const angleStep = (Math.PI * 2) / this.imagePlanes.length;
        
        this.imagePlanes.forEach((plane, index) => {
            // Static circular position calculation in local XZ plane
            const angle = index * angleStep;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = this.currentHeight; // Fixed Y position, no bobbing
            
            // Set position in LOCAL pathGroup space
            plane.position.set(x, y, z);
            
            // Get world positions for camera facing calculation
            const cameraWorldPosition = new THREE.Vector3();
            const planeWorldPosition = new THREE.Vector3();
            
            this.camera.getWorldPosition(cameraWorldPosition);
            plane.getWorldPosition(planeWorldPosition);
            
            // Make the plane face the camera using lookAt
            plane.lookAt(cameraWorldPosition);
        });
    }
    
    initThreeJS() {
        // Get initial frame size
        const frameSize = this.getFrameSize();
        
        // Create scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x121212);
        
        // Create camera
        this.camera = new THREE.PerspectiveCamera(75, frameSize.width / frameSize.height, 0.1, 1000);
        this.camera.position.set(0, 0, 10);
        this.camera.lookAt(0, 0, 0);
        
        // Create renderer
        this.renderer = new THREE.WebGLRenderer({ antialias: true });
        this.renderer.setSize(frameSize.width, frameSize.height);
        this.renderer.setPixelRatio(window.devicePixelRatio);
        
        // Add renderer to frame container
        this.frameContainer.appendChild(this.renderer.domElement);
        
        // Create parent group for manual rotation controls
        this.rotationGroup = new THREE.Group();
        this.scene.add(this.rotationGroup);
        
        // Create child group for internal animation
        this.pathGroup = new THREE.Group();
        this.rotationGroup.add(this.pathGroup);
        
        // Create circular path
        this.createCircularPath();
        
        // Add lighting
        this.addLighting();
        
        // Show initial placeholder
        this.showPlaceholders();
        
        // Start animation loop
        this.animate();
    }
    
    createCircularPath() {
        // Clear existing elements from the group (except image planes)
        const imagesToKeep = [...this.imagePlanes];
        while (this.pathGroup.children.length > 0) {
            const child = this.pathGroup.children[0];
            if (!imagesToKeep.includes(child)) {
                this.pathGroup.remove(child);
            } else {
                // Temporarily remove image planes
                this.pathGroup.remove(child);
            }
        }
        
        // Re-add image planes
        imagesToKeep.forEach(plane => this.pathGroup.add(plane));
        this.pathMarkers = [];
        
        // Create geometry for the circular path
        const radius = this.currentRadius;
        const segments = 64;
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        
        // Generate circular path vertices
        for (let i = 0; i <= segments; i++) {
            const angle = (i / segments) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = this.currentHeight; // Use height slider value instead of 0
            
            vertices.push(x, y, z);
        }
        
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
        
        // Create material for the path
        const material = new THREE.LineBasicMaterial({ 
            color: 0x00ff88,
            linewidth: 3
        });
        
        // Create the line and add to group
        this.circularPath = new THREE.Line(geometry, material);
        this.pathGroup.add(this.circularPath);
        
        // Add path markers to group
        this.addPathMarkers(radius, segments);
        
        // Apply current world rotation
        this.updateWorldRotation();
    }
    
    addPathMarkers(radius, segments) {
        // Add small spheres along the path
        const sphereGeometry = new THREE.SphereGeometry(0.05, 8, 8);
        const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        for (let i = 0; i < segments; i += 8) { // Every 8th point
            const angle = (i / segments) * Math.PI * 2;
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = this.currentHeight; // Use height slider value instead of 0
            
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(x, y, z);
            this.pathMarkers.push(sphere);
            this.pathGroup.add(sphere);
        }
        
        // Add a center reference point
        const centerGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        this.centerSphere = new THREE.Mesh(centerGeometry, centerMaterial);
        this.centerSphere.position.set(0, this.currentHeight, 0); // Use height slider value instead of hardcoded 0
        this.pathGroup.add(this.centerSphere);
    }
    
    updateCircularPath() {
        this.createCircularPath();
        this.updatePlaceholderPosition();
    }
    
    updateWorldRotation() {
        if (this.rotationGroup) {
            // Apply X and Z rotations in world space (global)
            // Reset rotation first, then apply world space rotations
            const currentLocalY = this.rotationGroup.rotation.y; // Preserve local Y rotation
            
            // Reset to identity
            this.rotationGroup.rotation.set(0, 0, 0);
            
            // Apply global X and Z rotations using Euler angles
            this.rotationGroup.rotation.x = THREE.MathUtils.degToRad(this.worldRotation.x);
            this.rotationGroup.rotation.z = THREE.MathUtils.degToRad(this.worldRotation.z);
            
            // Restore the local Y rotation (from automatic spinning)
            this.rotationGroup.rotation.y = currentLocalY;
        }
    }
    
    resetRotation() {
        this.worldRotation = { x: 0, y: 0, z: 0 };
        this.rotationXSlider.value = 0;
        this.rotationZSlider.value = 0;
        this.rotationXValue.textContent = '0°';
        this.rotationZValue.textContent = '0°';
        
        // Reset X and Z rotations but preserve Y (local spinning)
        const currentLocalY = this.rotationGroup.rotation.y;
        this.rotationGroup.rotation.set(0, currentLocalY, 0);
    }
    
    addLighting() {
        // Remove lighting since images use MeshBasicMaterial (unlit)
        // Only add minimal ambient light for other scene elements if needed
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
        this.scene.add(ambientLight);
    }
    
    animate() {
        this.animationId = requestAnimationFrame(() => this.animate());
        
        // STEP 1: Automatic Y rotation (continuous spin)
        this.rotationGroup.rotateY(THREE.MathUtils.degToRad(this.currentSpeed));
        
        // STEP 2: Calculate image positions (static, no animation)
        this.updateImagePositions();
        
        // STEP 3: Update placeholder position if it exists
        this.updatePlaceholderPosition();
        
        // STEP 4: Camera in fixed position (no automatic rotation)
        // Camera stays at fixed position set in initThreeJS
        
        this.renderer.render(this.scene, this.camera);
    }
    
    onWindowResize() {
        const frameSize = this.getFrameSize();
        
        if (this.camera && this.renderer) {
            this.camera.aspect = frameSize.width / frameSize.height;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(frameSize.width, frameSize.height);
        }
        
        // Handle 2D canvas resize
        if (this.canvas2D && this.currentPreset === 'follow-spline') {
            this.canvas2D.width = frameSize.width;
            this.canvas2D.height = frameSize.height;
            this.canvas2D.style.width = frameSize.width + 'px';
            this.canvas2D.style.height = frameSize.height + 'px';
            this.clearCanvas();
            
            // Redraw spline if it exists
            if (this.splinePoints.length > 0) {
                this.currentSpline = [...this.splinePoints];
                this.drawSpline();
            }
        }
    }
    
    applyFrameSize() {
        const width = parseInt(this.widthInput.value) || 800;
        const height = parseInt(this.heightInput.value) || 600;
        
        // Clamp values to reasonable limits
        const clampedWidth = Math.max(200, Math.min(2000, width));
        const clampedHeight = Math.max(150, Math.min(1500, height));
        
        // Update CSS custom properties
        document.documentElement.style.setProperty('--frame-width', `${clampedWidth}px`);
        document.documentElement.style.setProperty('--frame-height', `${clampedHeight}px`);
        
        // Update input fields with clamped values
        this.widthInput.value = clampedWidth;
        this.heightInput.value = clampedHeight;
        
        // Update Three.js renderer size
        if (this.renderer && this.camera) {
            this.camera.aspect = clampedWidth / clampedHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(clampedWidth, clampedHeight);
        }
        
        console.log(`Frame size updated to: ${clampedWidth}x${clampedHeight}`);
    }
    
    // Method to programmatically set frame size (useful for future extensions)
    setFrameSize(width, height) {
        this.widthInput.value = width;
        this.heightInput.value = height;
        this.applyFrameSize();
    }
    
    // Method to get current frame size
    getFrameSize() {
        return {
            width: parseInt(this.widthInput.value) || 800,
            height: parseInt(this.heightInput.value) || 600
        };
    }
    
    // Cleanup method
    destroy() {
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        if (this.renderer) {
            this.renderer.dispose();
        }
        
        // Cleanup uploaded images and textures
        this.imagePlanes.forEach(plane => {
            if (plane.geometry) plane.geometry.dispose();
            if (plane.material) {
                if (plane.material.map) plane.material.map.dispose();
                plane.material.dispose();
            }
        });
    }
    
    updateImageScales() {
        this.imagePlanes.forEach(plane => {
            const originalSize = plane.userData.originalSize;
            if (originalSize) {
                const aspectRatio = originalSize.width / originalSize.height;
                if (aspectRatio > 1) {
                    // Landscape
                    plane.scale.set(this.currentScale, this.currentScale / aspectRatio, 1);
                } else {
                    // Portrait
                    plane.scale.set(this.currentScale * aspectRatio, this.currentScale, 1);
                }
            }
        });
    }
    
    setup2DCanvas() {
        const frameSize = this.getFrameSize();
        
        // Create 2D canvas if it doesn't exist
        if (!this.canvas2D) {
            this.canvas2D = document.createElement('canvas');
            this.canvas2D.style.position = 'absolute';
            this.canvas2D.style.top = '0';
            this.canvas2D.style.left = '0';
            this.canvas2D.style.cursor = 'crosshair';
            this.frameContainer.appendChild(this.canvas2D);
            
            // Get 2D context
            this.ctx2D = this.canvas2D.getContext('2d');
        }
        
        // Set canvas size
        this.canvas2D.width = frameSize.width;
        this.canvas2D.height = frameSize.height;
        this.canvas2D.style.width = frameSize.width + 'px';
        this.canvas2D.style.height = frameSize.height + 'px';
        
        // Show canvas
        this.canvas2D.style.display = 'block';
        
        // Clear and set background, show instruction text if no spline exists
        if (this.splinePoints.length === 0) {
            this.drawSplinePlaceholder();
        } else {
            this.clearCanvas();
        }
    }
    
    createImagesAlongSpline() {
        // Prevent multiple simultaneous recreations
        if (this.isRecreatingImages) {
            return;
        }
        
        this.isRecreatingImages = true;
        
        // Stop any existing animation
        if (this.splineAnimationId) {
            cancelAnimationFrame(this.splineAnimationId);
            this.splineAnimationId = null;
        }
        
        if (this.splinePoints.length < 2) {
            // Clear images if no spline
            this.clear2DImages();
            this.isRecreatingImages = false;
            return;
        }
        
        // Ensure distances are calculated
        if (!this.splineCumulativeDistances) {
            this.calculateSplineDistances();
        }
        
        const totalDistance = this.splineCumulativeDistances[this.splineCumulativeDistances.length - 1];
        
        // Store old images for cleanup
        const oldImages = [...this.imageElements2D];
        this.imageElements2D = [];
        
        if (this.uploadedImages.length === 0) {
            // No images to display along spline
            // The instruction text will be handled by other methods
        } else {
            // Calculate number of duplicates based on density
            // Higher density = more duplicates (1 = few, 10 = lots)
            const duplicatesPerImage = this.splineImageDensity;
            const totalImages = this.uploadedImages.length * duplicatesPerImage;
            
            let imageIndex = 0;
            
            // Create images by cycling through the array (0,1,2,3,0,1,2,3...)
            for (let duplicate = 0; duplicate < duplicatesPerImage; duplicate++) {
                for (let originalIndex = 0; originalIndex < this.uploadedImages.length; originalIndex++) {
                    const imageData = this.uploadedImages[originalIndex];
                    this.create2DImageElement(imageData, imageIndex, totalImages, totalDistance);
                    imageIndex++;
                }
            }
        }
        
        // Use requestAnimationFrame for smooth cleanup
        requestAnimationFrame(() => {
            // Remove old images after new ones are rendered
            oldImages.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            
            // Allow new recreations
            this.isRecreatingImages = false;
            
            // Start single animation loop
            this.animate2DImages();
        });
    }
    
    create2DImageElement(imageData, index, totalImages, totalDistance) {
        const img = document.createElement('img');
        img.src = imageData.dataUrl;
        img.style.position = 'absolute';
        img.style.pointerEvents = 'none';
        img.style.zIndex = '10';
        img.style.borderRadius = '4px';
        img.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
        
        // Set initial size (we'll scale based on splineImageScale)
        img.onload = () => {
            const aspectRatio = img.naturalWidth / img.naturalHeight;
            const baseSize = 60; // Base size in pixels
            const scaledSize = baseSize * this.splineImageScale;
            
            if (aspectRatio > 1) {
                // Landscape
                img.style.width = scaledSize + 'px';
                img.style.height = (scaledSize / aspectRatio) + 'px';
            } else {
                // Portrait
                img.style.width = (scaledSize * aspectRatio) + 'px';
                img.style.height = scaledSize + 'px';
            }
        };
        
        img.userData = {
            imageId: imageData.id,
            index: index,
            animationOffset: (index / totalImages) * totalDistance // Spread images along spline in pixels
        };
        
        this.frameContainer.appendChild(img);
        this.imageElements2D.push(img);
    }
    
    clear2DImages() {
        // Stop animation
        if (this.splineAnimationId) {
            cancelAnimationFrame(this.splineAnimationId);
            this.splineAnimationId = null;
        }
        
        this.imageElements2D.forEach(img => {
            if (img.parentNode) {
                img.parentNode.removeChild(img);
            }
        });
        this.imageElements2D = [];
    }
    
    getSplinePosition(t) {
        // Normalize t to be between 0 and 1
        t = Math.max(0, Math.min(1, t));
        
        if (this.splinePoints.length < 2) {
            return { x: 0, y: 0 };
        }
        
        // Calculate cumulative distances if not already done
        if (!this.splineCumulativeDistances) {
            this.calculateSplineDistances();
        }
        
        // Get total distance
        const totalDistance = this.splineCumulativeDistances[this.splineCumulativeDistances.length - 1];
        const targetDistance = t * totalDistance;
        
        // Find the segment that contains our target distance
        for (let i = 0; i < this.splineCumulativeDistances.length - 1; i++) {
            const segmentStart = this.splineCumulativeDistances[i];
            const segmentEnd = this.splineCumulativeDistances[i + 1];
            
            if (targetDistance >= segmentStart && targetDistance <= segmentEnd) {
                // Linear interpolation within this segment
                const segmentDistance = segmentEnd - segmentStart;
                const segmentT = segmentDistance > 0 ? (targetDistance - segmentStart) / segmentDistance : 0;
                
                const startPoint = this.splinePoints[i];
                const endPoint = this.splinePoints[i + 1];
                
                const x = startPoint.x + (endPoint.x - startPoint.x) * segmentT;
                const y = startPoint.y + (endPoint.y - startPoint.y) * segmentT;
                
                return { x, y };
            }
        }
        
        // Fallback to last point
        const lastPoint = this.splinePoints[this.splinePoints.length - 1];
        return { x: lastPoint.x, y: lastPoint.y };
    }
    
    calculateSplineDistances() {
        this.splineCumulativeDistances = [0]; // Start with 0 distance
        
        for (let i = 1; i < this.splinePoints.length; i++) {
            const prevPoint = this.splinePoints[i - 1];
            const currPoint = this.splinePoints[i];
            
            // Calculate Euclidean distance between points
            const dx = currPoint.x - prevPoint.x;
            const dy = currPoint.y - prevPoint.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Add to cumulative distance
            const prevCumulative = this.splineCumulativeDistances[i - 1];
            this.splineCumulativeDistances.push(prevCumulative + distance);
        }
    }
    
    animate2DImages() {
        if (this.currentPreset !== 'follow-spline' || this.imageElements2D.length === 0) {
            this.splineAnimationId = null;
            return;
        }
        
        if (!this.splineCumulativeDistances) {
            this.splineAnimationId = null;
            return;
        }
        
        const totalDistance = this.splineCumulativeDistances[this.splineCumulativeDistances.length - 1];
        
        // Update animation distance (absolute pixels)
        this.splineAnimationDistance += this.splineAnimationSpeed;
        if (this.splineAnimationDistance > totalDistance) {
            this.splineAnimationDistance = 0; // Loop the animation
        }
        
        // Array to store images with their current t values for z-index calculation
        const imagesWithPosition = [];
        
        // Update each image position
        this.imageElements2D.forEach((element, index) => {
            const offset = element.userData.animationOffset;
            let currentDistance = (this.splineAnimationDistance + offset) % totalDistance;
            let t = currentDistance / totalDistance;
            
            const position = this.getSplinePosition(t);
            
            // Position the element (centered on the spline point)
            element.style.left = (position.x - element.offsetWidth / 2) + 'px';
            element.style.top = (position.y - element.offsetHeight / 2) + 'px';
            
            // Store for z-index calculation
            imagesWithPosition.push({ img: element, t });
        });
        
        // Sort by t value and assign z-index accordingly
        // Lower t values (start of spline) get lower z-index (behind)
        // Higher t values (end of spline) get higher z-index (in front)
        imagesWithPosition.sort((a, b) => a.t - b.t);
        imagesWithPosition.forEach((item, index) => {
            item.img.style.zIndex = (10 + index).toString();
        });
        
        // Continue animation and store frame ID
        this.splineAnimationId = requestAnimationFrame(() => this.animate2DImages());
    }
    
    updateSplineImageScales() {
        this.imageElements2D.forEach(element => {
            if (element.userData && element.userData.isPlaceholder) {
                // Update placeholder size
                element.style.width = (60 * this.splineImageScale) + 'px';
                element.style.height = (45 * this.splineImageScale) + 'px';
            } else if (element.naturalWidth && element.naturalHeight) {
                // Update image size
                const aspectRatio = element.naturalWidth / element.naturalHeight;
                const baseSize = 60; // Base size in pixels
                const scaledSize = baseSize * this.splineImageScale;
                
                if (aspectRatio > 1) {
                    // Landscape
                    element.style.width = scaledSize + 'px';
                    element.style.height = (scaledSize / aspectRatio) + 'px';
                } else {
                    // Portrait
                    element.style.width = (scaledSize * aspectRatio) + 'px';
                    element.style.height = scaledSize + 'px';
                }
            }
        });
    }
    
    showPlaceholders() {
        if (this.currentPreset === 'ring') {
            this.showRingPlaceholder();
        } else if (this.currentPreset === 'follow-spline') {
            this.showSplinePlaceholder();
        }
        this.hasPlaceholder = true;
    }
    
    removePlaceholders() {
        this.removeRingPlaceholder();
        this.removeSplinePlaceholder();
        this.hasPlaceholder = false;
    }
    
    showRingPlaceholder() {
        // Remove existing placeholder
        this.removeRingPlaceholder();
        
        // Create placeholder plane that will move around the circle
        const geometry = new THREE.PlaneGeometry(2, 1.5);
        const material = new THREE.MeshBasicMaterial({ 
            color: 0x2a2a2a,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.8
        });
        
        this.placeholderPlane = new THREE.Mesh(geometry, material);
        
        // Add border effect with wireframe
        const borderGeometry = new THREE.PlaneGeometry(2, 1.5);
        const borderMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x666666,
            wireframe: true,
            transparent: true,
            opacity: 0.6
        });
        const borderPlane = new THREE.Mesh(borderGeometry, borderMaterial);
        borderPlane.position.set(0, 0, 0.001); // Slightly in front
        
        // Group placeholder and border together
        const placeholderGroup = new THREE.Group();
        placeholderGroup.add(this.placeholderPlane);
        placeholderGroup.add(borderPlane);
        
        // Add to pathGroup so it moves with the circle
        this.pathGroup.add(placeholderGroup);
        this.placeholderPlane.borderPlane = borderPlane;
        this.placeholderPlane.group = placeholderGroup;
        
        // Position it on the circular path
        this.updatePlaceholderPosition();
    }
    
    removeRingPlaceholder() {
        if (this.placeholderPlane && this.placeholderPlane.group) {
            this.pathGroup.remove(this.placeholderPlane.group);
            
            // Dispose of border plane
            if (this.placeholderPlane.borderPlane) {
                this.placeholderPlane.borderPlane.geometry.dispose();
                this.placeholderPlane.borderPlane.material.dispose();
            }
            
            // Dispose of placeholder plane
            this.placeholderPlane.geometry.dispose();
            this.placeholderPlane.material.dispose();
            this.placeholderPlane = null;
        }
    }
    
    showSplinePlaceholder() {
        // This will be drawn in the drawSpline method when no spline exists
        if (this.ctx2D) {
            this.drawSplinePlaceholder();
        }
    }
    
    removeSplinePlaceholder() {
        // Will be removed when canvas is cleared or spline is drawn
    }
    
    drawSplinePlaceholder() {
        if (!this.ctx2D) return;
        
        this.clearCanvas();
        
        // Draw centered text instruction
        const canvasWidth = this.canvas2D.width;
        const canvasHeight = this.canvas2D.height;
        const centerX = canvasWidth / 2;
        const centerY = canvasHeight / 2;
        
        // Set text properties
        this.ctx2D.font = '16px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
        this.ctx2D.fillStyle = '#888888';
        this.ctx2D.textAlign = 'center';
        this.ctx2D.textBaseline = 'middle';
        
        // Draw the instruction text
        this.ctx2D.fillText('Draw a spline', centerX, centerY);
    }
    
    updatePlaceholderPosition() {
        if (this.placeholderPlane && this.placeholderPlane.group && this.currentPreset === 'ring') {
            // Position placeholder on the circular path like an image
            const radius = this.currentRadius + 1;
            const angle = 0; // Fixed position for placeholder
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = this.currentHeight;
            
            this.placeholderPlane.group.position.set(x, y, z);
            
            // Make it face the camera
            const cameraWorldPosition = new THREE.Vector3();
            this.camera.getWorldPosition(cameraWorldPosition);
            this.placeholderPlane.group.lookAt(cameraWorldPosition);
        }
    }
    
    createSplinePlaceholder(totalDistance) {
        // Create a div element as placeholder
        const placeholder = document.createElement('div');
        placeholder.style.position = 'absolute';
        placeholder.style.width = (60 * this.splineImageScale) + 'px';
        placeholder.style.height = (45 * this.splineImageScale) + 'px'; // 4:3 aspect ratio
        placeholder.style.backgroundColor = '#2a2a2a';
        placeholder.style.border = '1px solid #666666';
        placeholder.style.borderRadius = '4px';
        placeholder.style.pointerEvents = 'none';
        placeholder.style.zIndex = '10';
        placeholder.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
        
        placeholder.userData = {
            imageId: 'placeholder',
            index: 0,
            animationOffset: 0,
            isPlaceholder: true
        };
        
        this.frameContainer.appendChild(placeholder);
        this.imageElements2D.push(placeholder);
    }
}

// Initialize the template when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    window.projectTemplate = new ProjectTemplate();
}); 